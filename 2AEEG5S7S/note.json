{
  "paragraphs": [
    {
      "text": "%md\n- Traditional approach\n\n```\ndef toYesOrNo(choice: Int): String \u003d choice match {\n  case 1 \u003d\u003e \"yes\"\n  case 0 \u003d\u003e \"no\"\n  case _ \u003d\u003e \"error\"\n}\n\ndef toYesOrNo(choice: Int): String \u003d choice match {\n  case 1 | 2 | 3 \u003d\u003e \"yes\"\n  case 0         \u003d\u003e \"no\"\n  case _         \u003d\u003e \"error\"\n}\n\ndef parseArgument(arg: String) \u003d arg match {\n  case \"-h\" | \"--help\"    \u003d\u003e displayHelp\n  case \"-v\" | \"--version\" \u003d\u003e displayVerion\n  case whatever           \u003d\u003e unknownArgument(whatever)\n}\n```\n\n- Type Matching\n\n```\ndef f(x: Any): String \u003d x match {\n    case i:Int \u003d\u003e \"integer: \" + i\n    case _:Double \u003d\u003e \"a double\"\n    case s:String \u003d\u003e \"I want to say \" + s\n}\n```\n\n- Extractor\n\n```\n// Case Class\ncase class Address(street: String, county: String, state: String, country: String)\n\ndef extract(addr: Address) \u003d addr match {\n  case a @ Address(_, _, _, \"US\") \u003d\u003e s\"$a is in North America\"\n  case a @ Address(_, _, _, country) \u003d\u003e s\"$a is not a US address, but $country\"\n}\n\nprintln(extract(Address(\"ZhongShan RD No.1\", \"HuangPu\", \"ShangHai\", \"China\")))\nprintln(extract(Address(\"Main ST 1\", \"Sunnyvale\", \"CA\", \"US\")))\n\n// unapply function\ntrait User {\n  def name: String\n}\nclass FreeUser(val name: String) extends User\nclass PremiumUser(val name: String, val level: Int) extends User\n\nobject FreeUser {\n  def unapply(user: FreeUser): Option[String] \u003d Some(user.name)\n}\nobject PremiumUser {\n  def unapply(user: PremiumUser): Option[(String, Int)] \u003d Some((user.name, user.level))\n}\n\nval user1: User \u003d new PremiumUser(\"Daniel\", 3)\nval user2: User \u003d new FreeUser(\"Robert\")\n\ndef sayHi(user: User) \u003d user match {\n  case FreeUser(name) \u003d\u003e println(s\"Hello $name\")\n  case PremiumUser(name, level) \u003d\u003e println(s\"Welcome back, Level $level user $name\")\n}\n\nsayHi(user1)\nsayHi(user2)\n```\n\n- Matching on Collection\n\n```\ndef length[A](list : List[A]) : Int \u003d list match {\n  case _ :: tail \u003d\u003e 1 + length(tail)\n  case Nil \u003d\u003e 0\n}\n\nval seq \u003d Seq(1, 2, 3, 4)\nseq match {\n  case a :: b :: tail \u003d\u003e println (s\"first two [$a] [$b]\")\n  case _ \u003d\u003e sys.error(\"not found\")\n}\n\nseq match {\n  case a :: _ :: _ :: last :: Nil \u003d\u003e println (s\"first and last [$a] [$last]\")\n  case _ \u003d\u003e sys.error(\"not found\")\n}\n\nval seq1 \u003d Seq(1, 2, 3, 4)\nval seq2 \u003d Seq(2, 3, 4)\n\ndef matchFirst2(seq: Seq[Int]) \u003d seq match {\n  case 1 :: 2 :: tail \u003d\u003e println (\"first two element is 1 and 2\")\n  case _ \u003d\u003e println (\"first two element is not 1 and 2\")\n}\n\nmatchFirst2(seq1)\nmatchFirst2(seq2)\n```\n\n- Pattern Guard\n\n```\ncase class User(name: String, age: Int)\n\nval user1: User \u003d new User(\"Daniel\", 3)\nval user2: User \u003d new User(\"Robert\", 24)\n\ndef permit(user: User) \u003d user match {\n  case User(name, age) if age \u003e\u003d 18 \u003d\u003e println(s\"Hello $name, welcome!\")\n  case User(name, _) \u003d\u003e println(s\"Sorry $name, you must be older than 18\")\n}\n\npermit(user1)\npermit(user2)\n```\n\n- A little more complicated Example\n\n```\nabstract class Expr\ncase class Var(name: String) extends Expr\ncase class Number(num: Double) extends Expr\ncase class UnOp(operator: String, arg: Expr) extends Expr\ncase class BinOp(operator: String, left: Expr, right: Expr) extends Expr\n\ndef simplifyAll(expr: Expr): Expr \u003d expr match {\n  case UnOp(\"-\", UnOp(\"-\", e)) \u003d\u003e\n    simplifyAll(e) // `-\u0027 is its own inverse\n  case BinOp(\"/\", e1, e2 @ Number(d)) if d \u003d\u003d 0\u003d\u003e sys.error(\"cannot divide 0\")\n  case BinOp(\"+\", Number(0), e)\u003d\u003e\n    simplifyAll(e) // `0\u0027 is a neutral element for `+\u0027\n  case BinOp(\"*\", Number(1), e) \u003d\u003e\n    simplifyAll(e) // `1\u0027 is a neutral element for `*\u0027\n  case UnOp(op, e) \u003d\u003e\n    UnOp(op, simplifyAll(e))\n  case BinOp(op, l, r) \u003d\u003e\n    BinOp(op, simplifyAll(l), simplifyAll(r))\n  case _ \u003d\u003e expr\n}\n\n// -(-(0+2))\nval expr \u003d UnOp(\"-\",  UnOp(\"-\", BinOp(\"+\", Number(0), Number(2))))\nsimplifyAll(expr)\n// -(-(2/0))\nval expr \u003d UnOp(\"-\",  UnOp(\"-\", BinOp(\"/\", Number(2), Number(0))))\nsimplifyAll(expr)\n```",
      "config": {
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1422196605437_961094991",
      "id": "20150125-093645_558106670",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003cul\u003e\n\u003cli\u003eTraditional approach\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003edef toYesOrNo(choice: Int): String \u003d choice match {\n  case 1 \u003d\u0026gt; \"yes\"\n  case 0 \u003d\u0026gt; \"no\"\n  case _ \u003d\u0026gt; \"error\"\n}\n\ndef toYesOrNo(choice: Int): String \u003d choice match {\n  case 1 | 2 | 3 \u003d\u0026gt; \"yes\"\n  case 0         \u003d\u0026gt; \"no\"\n  case _         \u003d\u0026gt; \"error\"\n}\n\ndef parseArgument(arg: String) \u003d arg match {\n  case \"-h\" | \"--help\"    \u003d\u0026gt; displayHelp\n  case \"-v\" | \"--version\" \u003d\u0026gt; displayVerion\n  case whatever           \u003d\u0026gt; unknownArgument(whatever)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eType Matching\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003edef f(x: Any): String \u003d x match {\n    case i:Int \u003d\u0026gt; \"integer: \" + i\n    case _:Double \u003d\u0026gt; \"a double\"\n    case s:String \u003d\u0026gt; \"I want to say \" + s\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eExtractor\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003e// Case Class\ncase class Address(street: String, county: String, state: String, country: String)\n\ndef extract(addr: Address) \u003d addr match {\n  case a @ Address(_, _, _, \"US\") \u003d\u0026gt; s\"$a is in North America\"\n  case a @ Address(_, _, _, country) \u003d\u0026gt; s\"$a is not a US address, but $country\"\n}\n\nprintln(extract(Address(\"ZhongShan RD No.1\", \"HuangPu\", \"ShangHai\", \"China\")))\nprintln(extract(Address(\"Main ST 1\", \"Sunnyvale\", \"CA\", \"US\")))\n\n// unapply function\ntrait User {\n  def name: String\n}\nclass FreeUser(val name: String) extends User\nclass PremiumUser(val name: String, val level: Int) extends User\n\nobject FreeUser {\n  def unapply(user: FreeUser): Option[String] \u003d Some(user.name)\n}\nobject PremiumUser {\n  def unapply(user: PremiumUser): Option[(String, Int)] \u003d Some((user.name, user.level))\n}\n\nval user1: User \u003d new PremiumUser(\"Daniel\", 3)\nval user2: User \u003d new FreeUser(\"Robert\")\n\ndef sayHi(user: User) \u003d user match {\n  case FreeUser(name) \u003d\u0026gt; println(s\"Hello $name\")\n  case PremiumUser(name, level) \u003d\u0026gt; println(s\"Welcome back, Level $level user $name\")\n}\n\nsayHi(user1)\nsayHi(user2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eMatching on Collection\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003edef length[A](list : List[A]) : Int \u003d list match {\n  case _ :: tail \u003d\u0026gt; 1 + length(tail)\n  case Nil \u003d\u0026gt; 0\n}\n\nval seq \u003d Seq(1, 2, 3, 4)\nseq match {\n  case a :: b :: tail \u003d\u0026gt; println (s\"first two [$a] [$b]\")\n  case _ \u003d\u0026gt; sys.error(\"not found\")\n}\n\nseq match {\n  case a :: _ :: _ :: last :: Nil \u003d\u0026gt; println (s\"first and last [$a] [$last]\")\n  case _ \u003d\u0026gt; sys.error(\"not found\")\n}\n\nval seq1 \u003d Seq(1, 2, 3, 4)\nval seq2 \u003d Seq(2, 3, 4)\n\ndef matchFirst2(seq: Seq[Int]) \u003d seq match {\n  case 1 :: 2 :: tail \u003d\u0026gt; println (\"first two element is 1 and 2\")\n  case _ \u003d\u0026gt; println (\"first two element is not 1 and 2\")\n}\n\nmatchFirst2(seq1)\nmatchFirst2(seq2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ePattern Guard\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003ecase class User(name: String, age: Int)\n\nval user1: User \u003d new User(\"Daniel\", 3)\nval user2: User \u003d new User(\"Robert\", 24)\n\ndef permit(user: User) \u003d user match {\n  case User(name, age) if age \u0026gt;\u003d 18 \u003d\u0026gt; println(s\"Hello $name, welcome!\")\n  case User(name, _) \u003d\u0026gt; println(s\"Sorry $name, you must be older than 18\")\n}\n\npermit(user1)\npermit(user2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eA little more complicated Example\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003eabstract class Expr\ncase class Var(name: String) extends Expr\ncase class Number(num: Double) extends Expr\ncase class UnOp(operator: String, arg: Expr) extends Expr\ncase class BinOp(operator: String, left: Expr, right: Expr) extends Expr\n\ndef simplifyAll(expr: Expr): Expr \u003d expr match {\n  case UnOp(\"-\", UnOp(\"-\", e)) \u003d\u0026gt;\n    simplifyAll(e) // `-\u0027 is its own inverse\n  case BinOp(\"/\", e1, e2 @ Number(d)) if d \u003d\u003d 0\u003d\u0026gt; sys.error(\"cannot divide 0\")\n  case BinOp(\"+\", Number(0), e)\u003d\u0026gt;\n    simplifyAll(e) // `0\u0027 is a neutral element for `+\u0027\n  case BinOp(\"*\", Number(1), e) \u003d\u0026gt;\n    simplifyAll(e) // `1\u0027 is a neutral element for `*\u0027\n  case UnOp(op, e) \u003d\u0026gt;\n    UnOp(op, simplifyAll(e))\n  case BinOp(op, l, r) \u003d\u0026gt;\n    BinOp(op, simplifyAll(l), simplifyAll(r))\n  case _ \u003d\u0026gt; expr\n}\n\n// -(-(0+2))\nval expr \u003d UnOp(\"-\",  UnOp(\"-\", BinOp(\"+\", Number(0), Number(2))))\nsimplifyAll(expr)\n// -(-(2/0))\nval expr \u003d UnOp(\"-\",  UnOp(\"-\", BinOp(\"/\", Number(2), Number(0))))\nsimplifyAll(expr)\n\u003c/code\u003e\u003c/pre\u003e\n"
      },
      "dateCreated": "Jan 25, 2015 9:36:45 AM",
      "dateStarted": "Jan 25, 2015 9:43:27 AM",
      "dateFinished": "Jan 25, 2015 9:43:27 AM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1422196994080_-805719575",
      "id": "20150125-094314_871765451",
      "dateCreated": "Jan 25, 2015 9:43:14 AM",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    }
  ],
  "name": "Pattern Matching",
  "id": "2AEEG5S7S"
}